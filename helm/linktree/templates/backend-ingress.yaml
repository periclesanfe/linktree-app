# ============================================================================
# BACKEND INGRESS - ROTEAMENTO DE TRÁFEGO EXTERNO (PROD)
# ============================================================================
# Responsabilidade:
#   - Expõe o backend para acesso externo ao cluster
#   - Gerencia roteamento de tráfego HTTP/HTTPS
#   - Controla tráfego Canary via annotations do NGINX Ingress Controller
#
# Comunicação:
#   - NGINX Ingress Controller lê este recurso e configura NGINX
#   - Roteia tráfego para backend-service (stable) em operação normal
#   - Durante rollout Canary: divide tráfego entre stable e canary services
#   - Cert-manager provisiona certificados TLS (se habilitado)
#
# Canary Traffic Splitting:
#   - Argo Rollouts injeta/atualiza annotations automaticamente:
#     * nginx.ingress.kubernetes.io/canary: "true"
#     * nginx.ingress.kubernetes.io/canary-weight: "10" (10%, 25%, 50%, etc.)
#   - NGINX usa estas annotations para dividir requests entre services
#   - Mais preciso que pod-based splitting (controla % exato de requests)
#
# Fluxo de tráfego durante Canary:
#   1. Tráfego normal: 100% → backend-service (stable)
#   2. Rollout inicia: Argo Rollouts cria Ingress canary com weight: 10
#   3. NGINX divide: 10% → canary-service, 90% → stable-service
#   4. Steps progridem: weights aumentam (25%, 50%, 75%)
#   5. Rollout completa: 100% → novo stable, canary Ingress removido
#
# Uso em ambientes:
#   - DEV: Opcional (geralmente usa port-forward)
#   - PROD: Habilitado (acesso público via domínio)
# ============================================================================

{{- if and .Values.backend.enabled .Values.backend.ingress.enabled }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "linktree.backend.fullname" . }}-ingress
  labels:
    {{- include "linktree.backend.labels" . | nindent 4 }}
  annotations:
    # NGINX Ingress Controller class
    kubernetes.io/ingress.class: nginx

    # SSL/TLS configuration via cert-manager
    {{- if .Values.backend.ingress.tls.enabled }}
    cert-manager.io/cluster-issuer: {{ .Values.backend.ingress.tls.clusterIssuer }}
    {{- end }}

    # CORS configuration for API
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, PATCH, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-origin: {{ .Values.backend.config.corsOrigin | quote }}
    nginx.ingress.kubernetes.io/cors-allow-credentials: "true"

    # Proxy settings for API
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"

    # IMPORTANT: Canary annotations managed automatically by Argo Rollouts
    # During rollout, controller creates separate canary Ingress with:
    #   nginx.ingress.kubernetes.io/canary: "true"
    #   nginx.ingress.kubernetes.io/canary-weight: "<percentage>"
    # DO NOT add these annotations manually here

    # Sync wave for ArgoCD
    argocd.argoproj.io/sync-wave: "3"

    {{- with .Values.backend.ingress.annotations }}
    {{- toYaml . | nindent 4 }}
    {{- end }}

spec:
  {{- if .Values.backend.ingress.tls.enabled }}
  tls:
  - hosts:
    - {{ .Values.backend.ingress.host }}
    secretName: {{ include "linktree.backend.fullname" . }}-tls
  {{- end }}

  rules:
  - host: {{ .Values.backend.ingress.host }}
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            # Routes to stable service by default
            # Argo Rollouts will create canary Ingress to split traffic
            name: {{ include "linktree.backend.fullname" . }}
            port:
              number: {{ .Values.backend.service.port }}
{{- end }}
